<!DOCTYPE html><html lang="en_US"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>使用ArchLinux搭建路由器[转载]</title><meta name="robots" content="follow, index"/><meta name="description" content="Use Archlinux build router"/><meta property="og:url" content="https://wll.moe/posts/archrouter"/><link rel="canonical" href="https://wll.moe/posts/archrouter"/><meta property="og:site_name" content="使用ArchLinux搭建路由器[转载]"/><meta property="og:description" content="Use Archlinux build router"/><meta property="og:title" content="使用ArchLinux搭建路由器[转载]"/><meta name="next-head-count" content="10"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css" crossorigin="anonymous"/><link rel="preload" href="/_next/static/css/faf58ad7fda3e606.css" as="style"/><link rel="stylesheet" href="/_next/static/css/faf58ad7fda3e606.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-bb7fb0bd7df36df3.js" defer=""></script><script src="/_next/static/chunks/framework-442096ada787a3e7.js" defer=""></script><script src="/_next/static/chunks/main-8b5cdcba20904447.js" defer=""></script><script src="/_next/static/chunks/pages/_app-24f7877760d9c367.js" defer=""></script><script src="/_next/static/chunks/422-ce4a6cfc2d9b5e90.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-7f895d54294e0d20.js" defer=""></script><script src="/_next/static/TOOnME9HciIt2LKqRF6xE/_buildManifest.js" defer=""></script><script src="/_next/static/TOOnME9HciIt2LKqRF6xE/_ssgManifest.js" defer=""></script><script src="/_next/static/TOOnME9HciIt2LKqRF6xE/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><article class="container prose"><h1>使用ArchLinux搭建路由器[转载]</h1><div class="meta-line"><div class="meta"><time>Wed Apr 20 2022<!-- --> • </time><a class="tag" href="/Router">Router</a></div><a class="meta-back" href="/">Back</a></div><h1 id="安装系统"><a aria-hidden="true" tabindex="-1" href="#安装系统"><span class="icon icon-link"></span></a>安装系统</h1>
<p>安装 Arch Linux。不过，先跳过「设置网络管理器」这一步</p>
<h1 id="设置网络管理器"><a aria-hidden="true" tabindex="-1" href="#设置网络管理器"><span class="icon icon-link"></span></a>设置网络管理器</h1>
<p>这次，我们使用 <strong>systemd-networkd</strong>。</p>
<p>设备是双网口的，将会一个口做 WAN 口接外网，另一个口做 LAN 口（接交换机，接电脑，接 AP，接支持桥接的路由器 WAN 口，或者接关了 DHCP 的不支持桥接的路由器 LAN 口都可以）我们需要配置两个网络设置，并且支持不能用 en 了)
我们先 <code>ip addr</code> 看一下现在连接着的接口，就把它当作 WAN 口好了</p>
<ul>
<li>首先是 WAN 口的配置：</li>
</ul>
<pre><code class="hljs language-shell">sudo vim /etc/systemd/network/20-ext-dhcp.network`
</code></pre>
<pre><code class="hljs language-shell">[Match]
Name=enp4s0

[Network]
DHCP=ipv4
IPv6AcceptRA=yes # 接收 IPv6 的路由通告

[DHCPv4]
UseHostname=true
</code></pre>
<ul>
<li>然后来设置 LAN 口：</li>
</ul>
<pre><code class="hljs language-shell">sudo vim 21-int.network
</code></pre>
<pre><code class="hljs language-shell">[Match]
Name=enp3s0

[Link]
Multicast=yes

[Network]
Address=10.0.0.1/16
MulticastDNS=yes
IPMasquerade=both
IPv6SendRA=yes
DHCPv6PrefixDelegation=yes

[IPv6SendRA]
Managed=yes
OtherInformation=yes
</code></pre>
<p><strong>10.0.0.1/16</strong> 是将来软路由 LAN 口的 IP 地址和子网（如果看不懂 xx.xx.xx.xx/xx 这样的表示方式，了解一下 IP-CIDR）</p>
<ul>
<li>开启 DNS 服务器</li>
</ul>
<p>我们暂且使用 <strong>systemd-resolved</strong> 的 DNS 服务器。开启的方法非常简单，只要创建一个文件</p>
<pre><code class="hljs language-shell">sudo vim /etc/systemd/resolved.conf.d/listen-on-internal.conf
</code></pre>
<pre><code class="hljs language-shell">[Resolve]
DNSStubListenerExtra=10.0.0.1
</code></pre>
<p>然后，得确定 <strong>systemd-networkd</strong> 的两个服务启用</p>
<pre><code class="hljs language-shell">systemctl enable systemd-networkd
systemctl enable systemd-resolved
</code></pre>
<ul>
<li>设置 DHCP 服务器</li>
</ul>
<p>我们要用的 <strong>dhcpd</strong> 服务位于 dhcp 这个包</p>
<p>（dhcpcd 时 DHCP 客户端，c 代表 client，d 代表 daemon，后台服务）</p>
<pre><code class="hljs language-shell">sudo pacman -S dhcp
</code></pre>
<ul>
<li>然后创建文件</li>
</ul>
<pre><code class="hljs language-shell">sudo vim /etc/dhcpd.conf
</code></pre>
<p>在这里可以配置分配 IP 的范围，以及固定 IP 分配</p>
<pre><code class="hljs language-shell">option domain-name-servers 10.0.0.1;
option subnet-mask 255.255.0.0;
option routers 10.0.0.1;
subnet 10.0.0.0 netmask 255.255.0.0 {
    range 10.0.1.4 10.0.1.250;
    host clansty-mac {
        hardware ethernet f8:e4:3b:77:c1:b7;
        fixed-address 10.0.0.2;
    }
    host ap {
        hardware ethernet 28:d1:27:99:5b:26;
        fixed-address 10.0.2.1;
    }
}
</code></pre>
<p>另外，dhcpd 默认会在所有的接口上运行，我们需要稍微修改一下服务文件，给它加个参数</p>
<pre><code class="hljs language-shell">sudo cp /usr/lib/systemd/system/dhcpd4.service /etc/systemd/system/dhcpd4@.service
sudo vim /etc/systemd/system/dhcpd4@.service
</code></pre>
<pre><code class="hljs language-shell">  ...
  [Service]
  Type=forking
- ExecStart=/usr/bin/dhcpd -4 -q -cf /etc/dhcpd.conf -pf /run/dhcpd4/dhcpd.pid
+ ExecStart=/usr/bin/dhcpd -4 -q -cf /etc/dhcpd.conf -pf /run/dhcpd4/dhcpd.pid %I
  ...
</code></pre>
<p>然后我们启用服务就可以了</p>
<pre><code class="hljs language-shell">systemctl enable dhcpd4@enp3s0.service
</code></pre>
<ul>
<li>开启内核网络转发</li>
</ul>
<pre><code class="hljs language-shell">sudo vi /etc/sysctl.d/30-ipforward.conf
net.ipv4.ip_forward=1
net.ipv6.ip_forward=1
</code></pre>
<p>现在，重启进入系统，然后把电脑接到软路由刚才定义的 LAN 口上，电脑应该就能获取到 IP 地址，并且能上网了</p>
<h1 id="安装-clash"><a aria-hidden="true" tabindex="-1" href="#安装-clash"><span class="icon icon-link"></span></a>安装 Clash</h1>
<p>首先是安装软件包。<strong>clash-premium-bin</strong> 包在 Clansty 源里</p>
<pre><code class="hljs language-shell">sudo pacman -S clash-premium-bin
</code></pre>
<p>然后将你的 clash 配置文件放置在 <code>/etc/clash</code> 中。由于包里的服务文件是用户级别的，我们现在创建一个系统级别服务</p>
<pre><code class="hljs language-shell">sudo vim /etc/systemd/system/clash.service
</code></pre>
<pre><code class="hljs language-shell">[Unit]
Description=A rule based proxy in Go for neko.
After=network.target

[Service]
Type=exec
Restart=on-abort
ExecStart=/usr/bin/clash -d /etc/clash

[Install]
WantedBy=multi-user.target
</code></pre>
<p>然后，我们可以禁用 <strong>systemd-resolved</strong> 了。我们接下来要用 clash 自带的 DNS 服务器，实现 DOT，DOH 或是 FakeIP</p>
<pre><code class="hljs language-shell">sudo systemctl disable --now systemd-resolved
sudo rm /etc/resolv.conf
echo &#x27;nameserver 127.0.0.1&#x27; | sudo tee /etc/resolv.conf
</code></pre>
<p>Clash 的配置文件中要有以下内容</p>
<pre><code class="hljs language-shell">
tun:
  enable: true
  stack: system
  dns-hijack:
   - tcp://8.8.8.8:53
   - udp://8.8.8.8:53

dns:
  enable: true
  enhanced-mode: 是什么呢
  fake-ip-range: 198.19.0.1/16 # 将会是 tun 的子网
  listen: 0.0.0.0:53
  default-nameserver:
    # 用来找那些 DOH 域名的 IP 的 DNS 服务器
    - 223.5.5.5
    - 8.8.8.8
  nameserver:
    # 默认用这些服务器来查询
    - https://doh.pub/dns-query
    - https://dns.alidns.com/dns-query
  fallback:
<span class="hljs-meta prompt_">  	# </span><span class="bash">符合下一节的条件时，使用以下 DNS 服务器查询</span>
    - https://dns.google/dns-query
    - https://1.1.1.1/dns-query
  fallback-filter:
    geoip: true
    ipcidr:
      - 240.0.0.0/4
      - 127.0.0.1/8
      - 0.0.0.0/32
    domain:
      - +.google.com
      - +.twitter.com
      - +.google.com.hk
      - +.googleapis.com
  ipv6: true
</code></pre>
<p>一种不太对的配置方法
这是我刚开始的时候用的方法。用完之后感觉，怎么这么快就好了，不过好像有哪里不对。</p>
<p>这是基于 FakeIP 的方法，让 clash 的 DNS 返回虚拟的 IP 地址。而虚拟 IP 恰好在 Clash Tun 的子网下，请求会自动路由到 clash 中。</p>
<pre><code class="hljs language-shell">dns:
  enable: true
  enhanced-mode: fake-ip
sudo systemctl enable --now clash
</code></pre>
<p>这样之后，在电脑上打开一个浏览器，诶 网都能上了！</p>
<p>不过，后面转圈圈的 Telegram 还在转圈圈，需要指定代理为 <strong>10.0.0.1:7890</strong> 这样才能连上</p>
<p>出现这样的问题也就是因为 FakeIP 的原理，必须是经过 clash DNS 服务器进行解析的，通过域名的连接才会通过 clash</p>
<p>这么做其实应该说只是不推荐，不是不行。所以我写在这里</p>
<p>比较好（但是复杂）的配置方法
我们现在把 DNS 改为 <strong>redir-host</strong>，这时候 clash DNS 就会做一个普通 DNS 服务器的事，将安全的 DOT 或者 DOH 协议转换为 UDP53 的 DNS 协议</p>
<pre><code class="hljs language-shell">dns:
  enable: true
  enhanced-mode: fake-ip
</code></pre>
<p>这样之后，再启动 clash，我们的流量并没有经过 clash。</p>
<p>查看 <code>ip route</code> 发现，我们默认的流量路由还是 WAN 口的网卡。我们需要手动编辑路由表，把 LAN 口传入的到外网的流量传递给 tun 的网卡。</p>
<p>如果编辑主路由表的话，会导致 clash 自己连接服务器的流量也传递给自己，然后就造成循环了，这不好。所以我们编辑一张新的路由表，并且只用来处理 LAN 口流量</p>
<p>这里的 <strong>198.19.0.1</strong> 和 <strong>198.19.0.0/16</strong> 就对应配置文件中的 dns.fake-ip-range。如果没有设置 clash 的 DNS 服务器的话，默认将会是 198.18.0.1/16</p>
<pre><code class="hljs language-shell">sudo ip route add default via 198.19.0.1 dev utun table 233
sudo ip route add 198.19.0.0/16 dev utun table 233
sudo ip route add 10.0.0.0/16 dev enp3s0 table 233

sudo ip rule add from 10.0.0.0/16 table 233
</code></pre>
<p>这几行命令出了之后，后面的 Telegram 立即连上了，并且网页什么的也全都正常了。现在客户端获取到的 IP 也是真实的 IP（但这样会比 FakeIP 性能差一些）</p>
<p>然后，我们把这些写到脚本里面，并在 clash 启动之后就自动运行</p>
<pre><code class="hljs language-shell">sudo mkdir /etc/clash/scripts
sudo vi /etc/clash/scripts/setup.sh
</code></pre>
<pre><code class="hljs language-shell"><span class="hljs-meta prompt_">#</span><span class="bash">!/bin/bash</span>
<span class="hljs-meta prompt_">
#</span><span class="bash"><span class="hljs-built_in">wait</span> <span class="hljs-keyword">for</span> TUN device</span>
while ! ip address show utun &gt; /dev/null; do
    sleep 0.2
done
</code></pre>
<pre><code class="hljs language-shell">ip route flush table 233
ip route add default via 198.19.0.1 dev utun table 233
ip route add 198.19.0.0/16 dev utun table 233
ip route add 10.0.0.0/16 dev enp3s0 table 233

ip rule add from 10.0.0.0/16 table 233
</code></pre>
<p>再写一个在 clash 退出的时候还原配置的脚本</p>
<pre><code class="hljs language-shell">sudo vi /etc/clash/scripts/unsetup.sh
</code></pre>
<pre><code class="hljs language-shell"><span class="hljs-meta prompt_">#</span><span class="bash">!/bin/bash</span>

ip rule delete from all table 233
ip route flush table 233
</code></pre>
<p>稍微改一下 clash 的 <strong>systemd</strong> 服务，就是我们刚才创建的那个</p>
<pre><code class="hljs language-shell">  [Service]
  Type=exec
  Restart=on-abort
  ExecStart=/usr/bin/clash -d /etc/clash
+ ExecStartPost=+/etc/clash/scripts/setup.sh
+ ExecStopPost=+/etc/clash/scripts/unsetup.sh
</code></pre>
<p>这样之后，就算再重启，我们的服务也能正常了</p>
<hr/>
<p>转载自<a href="https://nyac.at/posts/archlinux-router">此文</a></p><small class="footer">© Willie <!-- -->2022<!-- -->.<a href="/feeds/atom.xml">RSS</a></small></article></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h1: \"h1\",\n      a: \"a\",\n      span: \"span\",\n      p: \"p\",\n      strong: \"strong\",\n      code: \"code\",\n      ul: \"ul\",\n      li: \"li\",\n      pre: \"pre\",\n      hr: \"hr\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.h1, {\n        id: \"安装系统\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": \"true\",\n          tabIndex: \"-1\",\n          href: \"#安装系统\",\n          children: _jsx(_components.span, {\n            className: \"icon icon-link\"\n          })\n        }), \"安装系统\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"安装 Arch Linux。不过，先跳过「设置网络管理器」这一步\"\n      }), \"\\n\", _jsxs(_components.h1, {\n        id: \"设置网络管理器\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": \"true\",\n          tabIndex: \"-1\",\n          href: \"#设置网络管理器\",\n          children: _jsx(_components.span, {\n            className: \"icon icon-link\"\n          })\n        }), \"设置网络管理器\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"这次，我们使用 \", _jsx(_components.strong, {\n          children: \"systemd-networkd\"\n        }), \"。\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"设备是双网口的，将会一个口做 WAN 口接外网，另一个口做 LAN 口（接交换机，接电脑，接 AP，接支持桥接的路由器 WAN 口，或者接关了 DHCP 的不支持桥接的路由器 LAN 口都可以）我们需要配置两个网络设置，并且支持不能用 en 了)\\n我们先 \", _jsx(_components.code, {\n          children: \"ip addr\"\n        }), \" 看一下现在连接着的接口，就把它当作 WAN 口好了\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"首先是 WAN 口的配置：\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo vim /etc/systemd/network/20-ext-dhcp.network`\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"[Match]\\nName=enp4s0\\n\\n[Network]\\nDHCP=ipv4\\nIPv6AcceptRA=yes # 接收 IPv6 的路由通告\\n\\n[DHCPv4]\\nUseHostname=true\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"然后来设置 LAN 口：\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo vim 21-int.network\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"[Match]\\nName=enp3s0\\n\\n[Link]\\nMulticast=yes\\n\\n[Network]\\nAddress=10.0.0.1/16\\nMulticastDNS=yes\\nIPMasquerade=both\\nIPv6SendRA=yes\\nDHCPv6PrefixDelegation=yes\\n\\n[IPv6SendRA]\\nManaged=yes\\nOtherInformation=yes\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"10.0.0.1/16\"\n        }), \" 是将来软路由 LAN 口的 IP 地址和子网（如果看不懂 xx.xx.xx.xx/xx 这样的表示方式，了解一下 IP-CIDR）\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"开启 DNS 服务器\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"我们暂且使用 \", _jsx(_components.strong, {\n          children: \"systemd-resolved\"\n        }), \" 的 DNS 服务器。开启的方法非常简单，只要创建一个文件\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo vim /etc/systemd/resolved.conf.d/listen-on-internal.conf\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"[Resolve]\\nDNSStubListenerExtra=10.0.0.1\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"然后，得确定 \", _jsx(_components.strong, {\n          children: \"systemd-networkd\"\n        }), \" 的两个服务启用\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"systemctl enable systemd-networkd\\nsystemctl enable systemd-resolved\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"设置 DHCP 服务器\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"我们要用的 \", _jsx(_components.strong, {\n          children: \"dhcpd\"\n        }), \" 服务位于 dhcp 这个包\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"（dhcpcd 时 DHCP 客户端，c 代表 client，d 代表 daemon，后台服务）\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo pacman -S dhcp\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"然后创建文件\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo vim /etc/dhcpd.conf\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"在这里可以配置分配 IP 的范围，以及固定 IP 分配\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"option domain-name-servers 10.0.0.1;\\noption subnet-mask 255.255.0.0;\\noption routers 10.0.0.1;\\nsubnet 10.0.0.0 netmask 255.255.0.0 {\\n    range 10.0.1.4 10.0.1.250;\\n    host clansty-mac {\\n        hardware ethernet f8:e4:3b:77:c1:b7;\\n        fixed-address 10.0.0.2;\\n    }\\n    host ap {\\n        hardware ethernet 28:d1:27:99:5b:26;\\n        fixed-address 10.0.2.1;\\n    }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"另外，dhcpd 默认会在所有的接口上运行，我们需要稍微修改一下服务文件，给它加个参数\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo cp /usr/lib/systemd/system/dhcpd4.service /etc/systemd/system/dhcpd4@.service\\nsudo vim /etc/systemd/system/dhcpd4@.service\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"  ...\\n  [Service]\\n  Type=forking\\n- ExecStart=/usr/bin/dhcpd -4 -q -cf /etc/dhcpd.conf -pf /run/dhcpd4/dhcpd.pid\\n+ ExecStart=/usr/bin/dhcpd -4 -q -cf /etc/dhcpd.conf -pf /run/dhcpd4/dhcpd.pid %I\\n  ...\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"然后我们启用服务就可以了\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"systemctl enable dhcpd4@enp3s0.service\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"开启内核网络转发\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo vi /etc/sysctl.d/30-ipforward.conf\\nnet.ipv4.ip_forward=1\\nnet.ipv6.ip_forward=1\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"现在，重启进入系统，然后把电脑接到软路由刚才定义的 LAN 口上，电脑应该就能获取到 IP 地址，并且能上网了\"\n      }), \"\\n\", _jsxs(_components.h1, {\n        id: \"安装-clash\",\n        children: [_jsx(_components.a, {\n          \"aria-hidden\": \"true\",\n          tabIndex: \"-1\",\n          href: \"#安装-clash\",\n          children: _jsx(_components.span, {\n            className: \"icon icon-link\"\n          })\n        }), \"安装 Clash\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"首先是安装软件包。\", _jsx(_components.strong, {\n          children: \"clash-premium-bin\"\n        }), \" 包在 Clansty 源里\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo pacman -S clash-premium-bin\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"然后将你的 clash 配置文件放置在 \", _jsx(_components.code, {\n          children: \"/etc/clash\"\n        }), \" 中。由于包里的服务文件是用户级别的，我们现在创建一个系统级别服务\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo vim /etc/systemd/system/clash.service\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"[Unit]\\nDescription=A rule based proxy in Go for neko.\\nAfter=network.target\\n\\n[Service]\\nType=exec\\nRestart=on-abort\\nExecStart=/usr/bin/clash -d /etc/clash\\n\\n[Install]\\nWantedBy=multi-user.target\\n\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"然后，我们可以禁用 \", _jsx(_components.strong, {\n          children: \"systemd-resolved\"\n        }), \" 了。我们接下来要用 clash 自带的 DNS 服务器，实现 DOT，DOH 或是 FakeIP\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo systemctl disable --now systemd-resolved\\nsudo rm /etc/resolv.conf\\necho 'nameserver 127.0.0.1' | sudo tee /etc/resolv.conf\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Clash 的配置文件中要有以下内容\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-shell\",\n          children: [\"\\ntun:\\n  enable: true\\n  stack: system\\n  dns-hijack:\\n   - tcp://8.8.8.8:53\\n   - udp://8.8.8.8:53\\n\\ndns:\\n  enable: true\\n  enhanced-mode: 是什么呢\\n  fake-ip-range: 198.19.0.1/16 # 将会是 tun 的子网\\n  listen: 0.0.0.0:53\\n  default-nameserver:\\n    # 用来找那些 DOH 域名的 IP 的 DNS 服务器\\n    - 223.5.5.5\\n    - 8.8.8.8\\n  nameserver:\\n    # 默认用这些服务器来查询\\n    - https://doh.pub/dns-query\\n    - https://dns.alidns.com/dns-query\\n  fallback:\\n\", _jsx(_components.span, {\n            className: \"hljs-meta prompt_\",\n            children: \"  \\t# \"\n          }), _jsx(_components.span, {\n            className: \"bash\",\n            children: \"符合下一节的条件时，使用以下 DNS 服务器查询\"\n          }), \"\\n    - https://dns.google/dns-query\\n    - https://1.1.1.1/dns-query\\n  fallback-filter:\\n    geoip: true\\n    ipcidr:\\n      - 240.0.0.0/4\\n      - 127.0.0.1/8\\n      - 0.0.0.0/32\\n    domain:\\n      - +.google.com\\n      - +.twitter.com\\n      - +.google.com.hk\\n      - +.googleapis.com\\n  ipv6: true\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"一种不太对的配置方法\\n这是我刚开始的时候用的方法。用完之后感觉，怎么这么快就好了，不过好像有哪里不对。\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"这是基于 FakeIP 的方法，让 clash 的 DNS 返回虚拟的 IP 地址。而虚拟 IP 恰好在 Clash Tun 的子网下，请求会自动路由到 clash 中。\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"dns:\\n  enable: true\\n  enhanced-mode: fake-ip\\nsudo systemctl enable --now clash\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"这样之后，在电脑上打开一个浏览器，诶 网都能上了！\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"不过，后面转圈圈的 Telegram 还在转圈圈，需要指定代理为 \", _jsx(_components.strong, {\n          children: \"10.0.0.1:7890\"\n        }), \" 这样才能连上\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"出现这样的问题也就是因为 FakeIP 的原理，必须是经过 clash DNS 服务器进行解析的，通过域名的连接才会通过 clash\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"这么做其实应该说只是不推荐，不是不行。所以我写在这里\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"比较好（但是复杂）的配置方法\\n我们现在把 DNS 改为 \", _jsx(_components.strong, {\n          children: \"redir-host\"\n        }), \"，这时候 clash DNS 就会做一个普通 DNS 服务器的事，将安全的 DOT 或者 DOH 协议转换为 UDP53 的 DNS 协议\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"dns:\\n  enable: true\\n  enhanced-mode: fake-ip\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"这样之后，再启动 clash，我们的流量并没有经过 clash。\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"查看 \", _jsx(_components.code, {\n          children: \"ip route\"\n        }), \" 发现，我们默认的流量路由还是 WAN 口的网卡。我们需要手动编辑路由表，把 LAN 口传入的到外网的流量传递给 tun 的网卡。\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"如果编辑主路由表的话，会导致 clash 自己连接服务器的流量也传递给自己，然后就造成循环了，这不好。所以我们编辑一张新的路由表，并且只用来处理 LAN 口流量\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"这里的 \", _jsx(_components.strong, {\n          children: \"198.19.0.1\"\n        }), \" 和 \", _jsx(_components.strong, {\n          children: \"198.19.0.0/16\"\n        }), \" 就对应配置文件中的 dns.fake-ip-range。如果没有设置 clash 的 DNS 服务器的话，默认将会是 198.18.0.1/16\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo ip route add default via 198.19.0.1 dev utun table 233\\nsudo ip route add 198.19.0.0/16 dev utun table 233\\nsudo ip route add 10.0.0.0/16 dev enp3s0 table 233\\n\\nsudo ip rule add from 10.0.0.0/16 table 233\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"这几行命令出了之后，后面的 Telegram 立即连上了，并且网页什么的也全都正常了。现在客户端获取到的 IP 也是真实的 IP（但这样会比 FakeIP 性能差一些）\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"然后，我们把这些写到脚本里面，并在 clash 启动之后就自动运行\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo mkdir /etc/clash/scripts\\nsudo vi /etc/clash/scripts/setup.sh\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-shell\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta prompt_\",\n            children: \"#\"\n          }), _jsx(_components.span, {\n            className: \"bash\",\n            children: \"!/bin/bash\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-meta prompt_\",\n            children: \"\\n#\"\n          }), _jsxs(_components.span, {\n            className: \"bash\",\n            children: [_jsx(_components.span, {\n              className: \"hljs-built_in\",\n              children: \"wait\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"for\"\n            }), \" TUN device\"]\n          }), \"\\nwhile ! ip address show utun \u003e /dev/null; do\\n    sleep 0.2\\ndone\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"ip route flush table 233\\nip route add default via 198.19.0.1 dev utun table 233\\nip route add 198.19.0.0/16 dev utun table 233\\nip route add 10.0.0.0/16 dev enp3s0 table 233\\n\\nip rule add from 10.0.0.0/16 table 233\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"再写一个在 clash 退出的时候还原配置的脚本\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"sudo vi /etc/clash/scripts/unsetup.sh\\n\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-shell\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta prompt_\",\n            children: \"#\"\n          }), _jsx(_components.span, {\n            className: \"bash\",\n            children: \"!/bin/bash\"\n          }), \"\\n\\nip rule delete from all table 233\\nip route flush table 233\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"稍微改一下 clash 的 \", _jsx(_components.strong, {\n          children: \"systemd\"\n        }), \" 服务，就是我们刚才创建的那个\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"hljs language-shell\",\n          children: \"  [Service]\\n  Type=exec\\n  Restart=on-abort\\n  ExecStart=/usr/bin/clash -d /etc/clash\\n+ ExecStartPost=+/etc/clash/scripts/setup.sh\\n+ ExecStopPost=+/etc/clash/scripts/unsetup.sh\\n\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"这样之后，就算再重启，我们的服务也能正常了\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.p, {\n        children: [\"转载自\", _jsx(_components.a, {\n          href: \"https://nyac.at/posts/archlinux-router\",\n          children: \"此文\"\n        })]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"frontMatter":{"wordCount":648,"slug":"archrouter","title":"使用ArchLinux搭建路由器[转载]","date":"2022-04-20","readingTime":"8 min read","description":"Use Archlinux build router","tags":["Router"]}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"archrouter"},"buildId":"TOOnME9HciIt2LKqRF6xE","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>